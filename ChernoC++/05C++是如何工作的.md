## 05C++是如何工作的

1.源文件 ->编译器 ->1.预处理语句    2.转化为常量数据或指令                 ->.obj（包含机器代码的文件，定义的常数数据）->link ->（包含所有内容的可执行文件）exe

2.#后面是预处理，编译器看到#之后的语句，先处理预处理语句，（实际编译之前就被处理了）

3.main函数可能没有返回值时，默认为0

4.iostream -> cout ->cin

5.预处理结束后，将C++代码转为实际的机器代码

6.x86:目标平台是Windows32位

7.debug模式通常会关掉优化（好处可以调试代码），所以相比release会慢

8.每一个.cpp文件编译之后会形成.obj目标文件，目标文件合并为一个可执行文件 ->link出现  就是将所有的obj链接  ->exe

9.申明就是告诉编译器存在，定义就是实现

10.申明就是 void Log(const char* message);

11.build 生成的时候，所有文件都会被编译，link链接器会找到函数，如果没有找到，发生链接错误

## 06编译器是如何工作的

1.预处理阶段的处理:编译器会遍历我们所有的预处理语句，并对其进行处理include if ifdef pragma

预处理打开文件阅读所有的内容 ctrl+v到.cpp之中

例子:EndBrace.h

```c++
}
```

主文件中

int xxxx

{

​	xxxx

#include EndBrace.h

可以实现正常的编译效果



C++预处理之后的文件.i

可以在VS之中设置，看到.i的文件内容位预处理之后替换的文件内容

```
#if 1
int Mult(int a,int b)
{
	int res =a* b;
	return res;
}
#endif
```



```
#if 0 //那么以下全是被禁用的代码
int Mult(int a,int b)
{
	int res =a* b;
	return res;
}
#endif
```

ctrl+F7 ->编译  build或者F5 编译+链接

.obj中文件全是二进制

入口点不一定是一个必须叫main的函数



sizeof(bool) =>1





函数的出现就是避免重复



#ifndef比#pragma once更加有意义

头文件.h可以用来声明A

MM.cpp 用于实现A函数

NN.cpp用于调用A函数

" "调用当前文件夹中的文件

<>调用某个路径文件



Git:

1.git clone

2.add (可有可无)

3.commit

4.push



F9：断点

F10 : STEP OVER 跳过

F11 :STEP INTO 

SHIFT+F11 STEP OUT



F5：启动调试，启动目标文件并将调试器附加到目标进程中，一般用于通过加断点调试用；

黄色箭头代表还未进入其中

watch:代表可以观看其中的值

内存中每2个数字一个字节 

8个16进制数字是4字节

可以在debug模式中查看 window ->memory 



汇编与反汇编

右键转移到反汇编之中

编译器会将源代码编译成汇编代码



反汇编视图对debug非常有用

1.源代码无法找到错误原因而只能求助于调试CPU(avoid这种情况)





mov: move的意思

jne:jump not equal 

![image-20220401110034804](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220401110034804.png)

不等就跳转到黄色箭头那一行之中

ebp- 0dch

ebp实际寄存器 -一定偏移量

bool的本质是1字节的数据类型

0 fasle

true 每个非0值

eax是寄存器

test eax是否能通过条件  

能：je :jump equal  true跳到别的地址

不能 不je  je:条件跳转语句

jmp普通跳转指令



const char* ptr ="Hello"

常量指针：指的东西永远是一个常量



for(int i=0;i<5;i++)

​	if(i%2==0)

​		continue

​	cout<<"hello";

continue作用跳过循环

i=1 3输出



一个指针就是一个保存地址的整数

一个指针就是一个地址

void 无类型

int a=8;

int* ptr= &a;

*ptr = 9;

char是一个字节

申请堆内存

char* buffer = new char[8];

memset(buffer,0,8);

char **ptr =&buffer;

delete[] buffer;

电脑几乎都是小端  倒过来



&a:获取变量的地址

int* b=&a;

1.引用

2.别名:ref就变成了a

int a=8;

int&ref=a;

ref=2;

a=====>2



```

#include <iostream>
void incr(int* value)
{
	(*value)++;///值
}
int main()
{
	int var = 8;
	incr(&var);  //传递的是地址
	std::cout << var;
	std::cin.get();
}
```



```
#include <iostream>
#include "Log.h"
void incr(int& value)
{
	value++;
}
int main()
{
	int var = 8;
	incr(var);
	std::cout << var;
	std::cin.get();
}
```



A=5 B=8

int& ref=A

ref=B;  //错误  必须给值

```
int a=5,b=8
int *ref =&a;///ref是&a 是a的地址
*ref=2;
ref=&b;  //想要获取 或 改变指针指向的值 可以添加defreference *
*ref=1;
```



静态变量

1.main.cpp static.cpp

main.cpp int xxx

static static int xxx   //内部翻译单元

这种情况可以编译

2.

main.cpp  int xxx

static.cpp int xxx

不能有2个同名的全局变量

3.

main.cpp extern int xxx

static.cpp int xxx

可以外部链接

4.

static.cpp static int xxx //相当于私有变量

main.cpp extern int xxx



函数

1.

static.cpp void func(){}

main.cpp voif func(){}

2个函数也是不可以的



2.

static.cpp static void func(){}

main.cpp void func(){}

没问题,互不干涉



3

static 类似类中的私有变量



当你在类和结构体之外使用static

**当声明静态函数与静态变量 只会被声明的文件所看到** 



如果不是真正需要全局变量，尽量使用static 

因为全局变量会到处进行链接



static在类或结构体之中：

static int x

static int y

x,y就不再是class member



class Entity

Entity e

Entity e2

e.x,e.y   

e2.x,e2.y  //都是内存中的同一个地址

​	无论创建多少个实例，都只会得到那个变量的一个版本

​	所以，通过类来引用静态变量是没有意义的



静态方法不能访问非静态变量 原因是静态方法没有类实例

static void func   int xxx



每一个类方法、每个非静态方法 获得当前类的一个实例作为参数



class和struct的区别

​	struct是public的

​	class是区分的



类作用域中，类中的任何东西都可以访问静态变量



静态成员变量在编译时存储在静态存储区。

定义过程应该在编译时完成

因此一定要在类外进行定义，但可以不初始化。



静态成员变量是所有实例共享的

但是其只是在类中进行**声明**，未初始化（分配内存）

类或者实例就无法访问静态成员变量

































